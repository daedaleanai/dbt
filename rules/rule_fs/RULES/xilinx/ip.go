package xilinx

import (
	"fmt"

	"dbt-rules/RULES/core"
	"dbt-rules/RULES/hdl"
	h "dbt-rules/hdl"
)

func init() {
	core.AssertIsBuildableTarget(&Ip{})
}

type IpScriptParams struct {
	PartName   string
	BoardName  string
	Name       string
	Design     core.Path
	XciPath    string
	OutSim     core.OutPath
	OutXci     core.OutPath
	BoardFiles []core.Path
	SimScripts map[string]core.Path
	DataFiles  map[string]core.OutPath
	Verbose    bool
}

// Create an IP checkpoint, simulation artifacts, and optionally other data
type Ip struct {
	// Name of the module as specified in the design file
	ModuleName string

	// Output XCI checkpoint
	OutXci core.OutPath

	// Output simulation artifacts
	OutSim core.OutPath

	// The TCL file generating the IP block
	Design core.Path

	// Optional XCI path relative to the output directory generated by Vivado, if different from the dufault
	XciPath string

	// List of directories with board definitions
	BoardFiles []core.Path

	// Map of scripts for loading the IP into a simulator. The key is the name of the simulator or "generic-sim".
	SimScripts map[string]core.Path

	// Extra data files to be extracted from the output directory generated by Vivado. The key is the path relative to the
	// top of that directory, the value is the target path.
	DataFiles map[string]core.OutPath
	Verbose   bool
}

func (rule Ip) Build(ctx core.Context) {
	xciPath := rule.XciPath
	if xciPath == "" {
		xciPath = fmt.Sprintf("./.srcs/sources_1/ip/%s/%s.xci", rule.ModuleName, rule.ModuleName)
	}

	data := IpScriptParams{
		PartName:   hdl.PartName.Value(),
		BoardName:  hdl.BoardName.Value(),
		Name:       rule.ModuleName,
		Design:     rule.Design,
		XciPath:    xciPath,
		OutXci:     rule.OutXci,
		OutSim:     rule.OutSim,
		BoardFiles: rule.BoardFiles,
		SimScripts: rule.SimScripts,
		DataFiles:  rule.DataFiles,
		Verbose:    rule.Verbose,
	}

	ctx.AddBuildStep(core.BuildStep{
		Outs:   append([]core.OutPath{rule.OutXci, rule.OutSim}, core.GetSortedOutPaths(rule.DataFiles)...),
		Ins:    append([]core.Path{rule.Design}, core.GetSortedPaths(rule.SimScripts)...),
		Script: core.CompileTemplateFile(h.XilinxIpScriptTmpl.String(), data),
		Descr:  fmt.Sprintf("Generating IP from %s", rule.Design.Relative()),
	})
}

func (rule Ip) Sources() []core.Path {
	return []core.Path{
		rule.OutSim,
		rule.OutXci,
	}
}

func (rule Ip) Data() []core.Path {
	paths := []core.Path{}
	for _, path := range rule.DataFiles {
		paths = append(paths, path)
	}
	return paths
}

func (rule Ip) Ips() []hdl.Ip {
	return []hdl.Ip{}
}
